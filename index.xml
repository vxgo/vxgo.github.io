<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>胡言乱语 on 胡言乱语</title>
    <link>https://vxgo.github.io/</link>
    <description>Recent content in 胡言乱语 on 胡言乱语</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 23 Aug 2018 15:15:07 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JVM-垃圾回收（二）</title>
      <link>https://vxgo.github.io/2018/08/23/jvm-gc2/</link>
      <pubDate>Thu, 23 Aug 2018 15:15:07 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/08/23/jvm-gc2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;接着上次 JVM 中 GC 机制的总结，这次主要复习一下垃圾收集的常用算法和 Minor GC、Full GC 相关的一些知识点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一-垃圾收集算法&#34;&gt;一、垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&#34;1-1-标记-清除-mark-sweep&#34;&gt;1.1 标记 - 清除（Mark-Sweep）&lt;/h3&gt;

&lt;p&gt;算法分成 “标记”、“清除” 两个阶段：首先标记出所有需要回收的对象（两次标记），在标记完成后统一回收所有被标记的对象。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/687148dbly1ftwah4c7cxj20gv07b0sz.jpg&#34; alt=&#34;&#34; /&gt;

标记－清除算法的不足主要有以下两点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空间问题&lt;/strong&gt;，会产生大量不连续的内存碎片，导致无法给大对象分配内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率问题&lt;/strong&gt;，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-标记-整理-mark-compact&#34;&gt;1.2 标记 - 整理（Mark-Compact）&lt;/h3&gt;

&lt;p&gt;此算法的标记过程与标记－清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。具体示意图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/687148dbly1ftwamib399j20hq06f0t0.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-3-复制-copying&#34;&gt;1.3 复制（Copying）&lt;/h3&gt;

&lt;p&gt;将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。主要不足是只使用了内存的一半。&lt;/p&gt;

&lt;p&gt;复制算法过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/687148dbly1ftwao1yh4wj20j00670t3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-4-分代收集&#34;&gt;1.4 分代收集&lt;/h3&gt;

&lt;p&gt;JVM 采用分代收集（Generational Collection）算法，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新生代使用复制算法&lt;/strong&gt; 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;老年代使用标记 - 清理 或者 标记 - 整理 算法&lt;/strong&gt; 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或 “标记 - 整理” 算法来进行回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-minor-gc-和-full-gc&#34;&gt;二、Minor GC 和 Full GC&lt;/h2&gt;

&lt;h3 id=&#34;2-1-minor-gc&#34;&gt;2.1 Minor GC&lt;/h3&gt;

&lt;p&gt;发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。&lt;/p&gt;

&lt;p&gt;Minor GC 会使用复制收集算法进行垃圾回收，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。&lt;/p&gt;

&lt;h3 id=&#34;2-2-full-gc&#34;&gt;2.2 Full GC&lt;/h3&gt;

&lt;p&gt;发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/p&gt;

&lt;h3 id=&#34;2-3-full-gc-的触发条件&#34;&gt;2.3 Full GC 的触发条件&lt;/h3&gt;

&lt;p&gt;对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p&gt;

&lt;h4 id=&#34;2-3-1-调用-system-gc&#34;&gt;2.3.1 调用 &lt;code&gt;System.gc()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 &lt;code&gt;-XX:+ DisableExplicitGC&lt;/code&gt; 虚拟机参数来禁止 RMI 调用 &lt;code&gt;System.gc()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;2-3-2-老年代空间不足&#34;&gt;2.3.2 老年代空间不足&lt;/h4&gt;

&lt;p&gt;老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p&gt;

&lt;p&gt;为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 &lt;code&gt;-Xmn&lt;/code&gt; 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 &lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt; 虚拟机参数调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p&gt;

&lt;h4 id=&#34;2-3-3-空间分配担保失败&#34;&gt;2.3.3 空间分配担保失败&lt;/h4&gt;

&lt;p&gt;使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。&lt;/p&gt;

&lt;h4 id=&#34;2-3-4-jdk-1-7-及以前的永久代空间不足&#34;&gt;2.3.4 JDK 1.7 及以前的永久代空间不足&lt;/h4&gt;

&lt;p&gt;在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS 垃圾收集器的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS 垃圾收集器。&lt;/p&gt;

&lt;p&gt;在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。&lt;/p&gt;

&lt;h4 id=&#34;2-3-5-concurrent-mode-failure&#34;&gt;2.3.5 Concurrent Mode Failure&lt;/h4&gt;

&lt;p&gt;使用 CMS 垃圾收集器执行的过程中，同时有对象要放入老年代，而此时老年代空间不足（有时候 “&lt;strong&gt;空间不足&lt;/strong&gt;” 是指 CMS GC 当前的浮动垃圾过多导致暂时性的空间不足），便会报 &lt;code&gt;Concurrent Mode Failure&lt;/code&gt; 错误，并触发 Full GC。&lt;/p&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>JVM-垃圾回收（一）</title>
      <link>https://vxgo.github.io/2018/08/23/jvm-gc1/</link>
      <pubDate>Thu, 23 Aug 2018 11:25:52 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/08/23/jvm-gc1/</guid>
      <description>&lt;p&gt;在 JVM 运行时数据区域中，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。&lt;/p&gt;

&lt;h2 id=&#34;一-判断对象状态&#34;&gt;一、判断对象状态&lt;/h2&gt;

&lt;p&gt;JVM 在回收一个对象时，首先要判断这个对象的状态，如果判断对象为无效的（没有被任何对象或变量引用），则需要被 JVM 垃圾回收器回收。&lt;/p&gt;

&lt;h3 id=&#34;1-1-引用计数算法&#34;&gt;1.1 引用计数算法&lt;/h3&gt;

&lt;p&gt;给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数不为 0 的对象仍然存活。
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ReferenceCountingGC {
    public Object instance = null;

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // 假设在这行发生 GC，objA 和 objB 是否能被回收？
        System.gc();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;testGC()&lt;/code&gt; 方法执行后，&lt;code&gt;objA&lt;/code&gt; 和 &lt;code&gt;objB&lt;/code&gt; 不会被垃圾回收器回收，因为&lt;strong&gt;两个对象出现了循环引用，引用计数器永远不为 0，导致无法对它们进行回收&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;虽然引用计数算法简单、高效，但是因为存在循环引用的问题，所以 JVM 并没有使用引用计数算法标记对象状态。&lt;/p&gt;

&lt;h3 id=&#34;1-2-可达性分析算法&#34;&gt;1.2 可达性分析算法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;可达性分析（Tracing GC）&lt;/strong&gt;通过 &lt;strong&gt;GC Roots&lt;/strong&gt; 作为起始节点向下进行搜索，GC Roots 搜索的经过的路径称为&lt;strong&gt;引用链（Reference Chain）&lt;/strong&gt;，能够到达到的对象都是存活的（也就是引用链上的对象），不可达的对象被标记为无效的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/687148dbly1ftcw0cnpk7j20ez08d0sz.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图 Object5、Object6 和 Object7 虽然相互存在引用关系，但是 GC Roots 不可达，形成不了引用链，所以会被标记为无效的对象。&lt;/p&gt;

&lt;p&gt;JVM 使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虚拟机栈中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有引用类型的变量才有可能被认为是 GC Roots，值类型的变量永远不被认为是 GC Roots。而且 GC Roots 并不包括堆中对象所引用的对象，这样就不会出现循环引用。&lt;/p&gt;

&lt;p&gt;可作为 GC Roots 的节点主要在全局性的引用与执行上下文中，GC Roots 必须是当前存活的引用类型对象。GC 管理的区域是 Java 堆，而虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC Roots 的一部分。&lt;/p&gt;

&lt;h2 id=&#34;二-垃圾回收过程&#34;&gt;二、垃圾回收过程&lt;/h2&gt;

&lt;p&gt;即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于 “缓刑” 阶段，要真正宣告一个对象 “死亡”，至少要经历两次标记过程。&lt;/p&gt;

&lt;h3 id=&#34;2-1-第一次标记&#34;&gt;2.1 第一次标记&lt;/h3&gt;

&lt;p&gt;如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是该对象是否覆盖了 &lt;code&gt;finalize()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若已覆盖该方法，并该对象的 &lt;code&gt;finalize()&lt;/code&gt; 方法还没有被执行过，那么就会将 &lt;code&gt;finalize()&lt;/code&gt; 扔到 F-Queue 队列中。&lt;/li&gt;
&lt;li&gt;若未覆盖该方法，或者该对象的 &lt;code&gt;finalize()&lt;/code&gt; 方法已经被执行过，则直接回收释放对象内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-第二次标记&#34;&gt;2.2 第二次标记&lt;/h3&gt;

&lt;p&gt;JVM 会自动建立一个低优先级的 Finalizer 线程去执行执行 F-Queue 队列中的 &lt;code&gt;finalize()&lt;/code&gt; 方法。为了防止 F-Queue 队列中的其它对象长时间处于等待状态，而导致整个内存回收系统崩溃，一个对象在 &lt;code&gt;finalize()&lt;/code&gt; 方法中执行缓慢，或者发生了死循环（更极端的情况），JVM 就直接停止其执行，将该对象清除回收。所以 JVM 不会让 F-Queue 队列等待所有的 &lt;code&gt;finalize()&lt;/code&gt; 方法都执行结束。&lt;/p&gt;

&lt;h3 id=&#34;2-3-对象重生或死亡&#34;&gt;2.3 对象重生或死亡&lt;/h3&gt;

&lt;p&gt;如果某个对象的 &lt;code&gt;finalize()&lt;/code&gt; 方法时被执行时，与引用链上的任何一个对象建立了关联（例如：把自己（this 关键字）赋值给某个类变量或者对象的成员变量），那么该对象就在第二次标记时被移出 “即将回收” 的集合；如果没有，那么就会被垃圾收集器清除回收。&lt;/p&gt;

&lt;p&gt;任何一个对象的 &lt;code&gt;finalize()&lt;/code&gt; 方法都只会被 JVM 调用一次，所以自救也只能进行一次，如果回收的对象之前调用了 &lt;code&gt;finalize()&lt;/code&gt; 方法，后面回收时就不会调用 &lt;code&gt;finalize()&lt;/code&gt; 方法了。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;finalize()&lt;/code&gt; 方法来 “拯救” 对象是不值得提倡的，因为它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。&lt;code&gt;finalize()&lt;/code&gt; 能做的工作，使用 &lt;code&gt;try-finally&lt;/code&gt; 或者其它方法都更适合、及时。&lt;/p&gt;

&lt;h2 id=&#34;三-方法区的回收&#34;&gt;三、方法区的回收&lt;/h2&gt;

&lt;p&gt;因为在 JDK 8 之前方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。&lt;/p&gt;

&lt;p&gt;主要是对常量池的回收和对类的卸载。&lt;/p&gt;

&lt;p&gt;类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。&lt;/li&gt;
&lt;li&gt;加载该类的 ClassLoader 已经被回收。&lt;/li&gt;
&lt;li&gt;该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。&lt;/p&gt;

&lt;p&gt;在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。&lt;/p&gt;

&lt;h2 id=&#34;四-引用类型&#34;&gt;四、引用类型&lt;/h2&gt;

&lt;p&gt;无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。&lt;/p&gt;

&lt;p&gt;Java 具有四种强度不同的引用类型。&lt;/p&gt;

&lt;h3 id=&#34;4-1-强引用&#34;&gt;4.1 强引用&lt;/h3&gt;

&lt;p&gt;被强引用关联的对象不会被垃圾收集器回收。&lt;/p&gt;

&lt;p&gt;使用 new 一个新对象的方式来创建强引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-2-软引用&#34;&gt;4.2 软引用&lt;/h3&gt;

&lt;p&gt;被软引用关联的对象，只有在内存不够的情况下才会被回收。&lt;/p&gt;

&lt;p&gt;使用 SoftReference 类来创建软引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
SoftReference&amp;lt;Object&amp;gt; sf = new SoftReference&amp;lt;Object&amp;gt;(obj);
obj = null;  // 使对象只被软引用关联
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-3-弱引用&#34;&gt;4.3 弱引用&lt;/h3&gt;

&lt;p&gt;被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。&lt;/p&gt;

&lt;p&gt;使用 WeakReference 类来实现弱引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
WeakReference&amp;lt;Object&amp;gt; wf = new WeakReference&amp;lt;Object&amp;gt;(obj);
obj = null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConcurrentCache&amp;lt;K, V&amp;gt; {

    private final int size;

    private final Map&amp;lt;K, V&amp;gt; eden;

    private final Map&amp;lt;K, V&amp;gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&amp;lt;&amp;gt;(size);
        this.longterm = new WeakHashMap&amp;lt;&amp;gt;(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &amp;gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-4-虚引用&#34;&gt;4.4 虚引用&lt;/h3&gt;

&lt;p&gt;又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。&lt;/p&gt;

&lt;p&gt;为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。&lt;/p&gt;

&lt;p&gt;使用 PhantomReference 来实现虚引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
PhantomReference&amp;lt;Object&amp;gt; pf = new PhantomReference&amp;lt;Object&amp;gt;(obj);
obj = null;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;!-- [1]: /images/post/jvm-gc-1.jpg
 --&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 位运算笔记</title>
      <link>https://vxgo.github.io/2018/08/02/java-positional-operator/</link>
      <pubDate>Thu, 02 Aug 2018 17:24:58 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/08/02/java-positional-operator/</guid>
      <description>&lt;p&gt;一些零碎的知识点总是似懂非懂，用法老是模棱两可，每次都要去网络上查询，长时间不用又忘记了。比如 Java 中的位运算。今天抽空归纳总结一下，加强一下记忆。&lt;/p&gt;

&lt;h2 id=&#34;一-原码-反码和补码&#34;&gt;一、原码、反码和补码&lt;/h2&gt;

&lt;h3 id=&#34;1-1-原码&#34;&gt;1.1 原码&lt;/h3&gt;

&lt;p&gt;一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为 0, 负数为 1。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。&lt;/p&gt;

&lt;p&gt;原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如 8 位二进制:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[+1] 原 = 0000 0001
[-1] 原 = 1000 0001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一位是符号位，因为第一位是符号位，所以 8 位二进制数的取值范围就是：[1111 1111 , 0111 1111]，即：[-127 , 127]
&lt;/p&gt;

&lt;h3 id=&#34;1-2-反码&#34;&gt;1.2 反码&lt;/h3&gt;

&lt;p&gt;反码的表示方法是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[+1] = [00000001] 原 = [00000001] 反
[-1] = [10000001] 原 = [11111110] 反
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-3-补码&#34;&gt;1.3 补码&lt;/h3&gt;

&lt;p&gt;补码的表示方法是：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 + 1。(即在反码的基础上 + 1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[+1] = [00000001] 原 = [00000001] 反 = [00000001] 补
[-1] = [10000001] 原 = [11111110] 反 = [11111111] 补
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-左移运算&#34;&gt;二、左移运算（&amp;lt;&amp;lt;）&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;value &amp;lt;&amp;lt; num&lt;/code&gt;
&amp;gt; num 指定要移位值；value 移动的位数。&lt;/p&gt;

&lt;p&gt;将左操作数（value）转为二进制数后向左边移动 num 位，并且在低位补 0，高位丢弃。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;5 &amp;lt;&amp;lt; 2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0101     5 的补码（同原码）
0000 0000 0000 0000 0000 0000 0001 0100     左移 2 位后，低位补 0。换算成 10 进制为 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如：对 int 类型（最大位数 32）的数值移动 33 位，实际上只移动了 &lt;code&gt;33 % 32 = 1&lt;/code&gt; 位。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：n 位二进制，最高位为符号位，因此表示的数值范围：$ -2^{(n-1)} $ —— $ 2^{(n-1)}-1 $，所以模为：$ 2^{(n-1)} $。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。如：&lt;code&gt;5 &amp;lt;&amp;lt; 2&lt;/code&gt; 相当于 $ 5 * 2^2 = 20 $。&lt;/p&gt;

&lt;p&gt;如果移进高阶位（int 31 或 long 63 位），那么该值将变为负值。如：&lt;code&gt;1 &amp;lt;&amp;lt; 31 = -2147483648&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-右移运算&#34;&gt;三、右移运算（&amp;gt;&amp;gt;）&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;value &amp;gt;&amp;gt; num&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;num 指定要移位值；value 移动的位数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将左操作数（value）转为二进制数后向右边移动 num 位，符号位不变，高位补上符号位（若左操作数是正数，则高位补 0，若左操作数是负数，则高位补 1），低位丢弃。&lt;/p&gt;

&lt;p&gt;右移时，被移走的最高位（最左边的位）由原来最高位的数字补充，这叫做符号位扩展（保留符号位）（sign extension），在进行右移操作时用来保持负数的符号。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;7 &amp;gt;&amp;gt; 2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0111     7 的补码（同原码）
0000 0000 0000 0000 0000 0000 0000 0001     右移 2 位后，高位补 0。换算成 10 进制为 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;code&gt;-7 &amp;gt;&amp;gt; 2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0111     -7 的原码
1111 1111 1111 1111 1111 1111 1111 1000     -7 的反码
1111 1111 1111 1111 1111 1111 1111 1001     -7 的补码
1111 1111 1111 1111 1111 1111 1111 1110     右移 2 位后，高位补 1
1000 0000 0000 0000 0000 0000 0000 0010     补码转原码。换算成 10 进制为 -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正数右移 n 位相当于除以 2 的 n 次方并且舍弃了余数。如：&lt;code&gt;7 &amp;gt;&amp;gt; 2&lt;/code&gt; 相当于： $ 7 / 2^2 = 1 $。&lt;/p&gt;

&lt;p&gt;负数右移 n 位相当于除以 2 的 n 次方，如果有余数 -1。如：&lt;code&gt;-7 &amp;gt;&amp;gt; 2&lt;/code&gt; 相当于： $ 7 * 2^2 -1= -2 $。&lt;/p&gt;

&lt;h2 id=&#34;四-无符号右移&#34;&gt;四、无符号右移（&amp;gt;&amp;gt;&amp;gt;）&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;value &amp;gt;&amp;gt;&amp;gt; num&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;num 指定要移位值；value 移动的位数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将左操作数（value）转为二进制数后向右边移动 num 位，0 补最高位（忽略了符号位扩展）。&lt;/p&gt;

&lt;p&gt;无符号右移运算只是对 32 位和 64 位的值有意义。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;-7 &amp;gt;&amp;gt;&amp;gt; 2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0111     -7 的原码
1111 1111 1111 1111 1111 1111 1111 1001     -7 的补码
0011 1111 1111 1111 1111 1111 1111 1110     右移 2 位后，高位补 0。换算成 10 进制为 1073741822
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-位逻辑运算符&#34;&gt;五、位逻辑运算符&lt;/h2&gt;

&lt;h3 id=&#34;5-1-与运算&#34;&gt;5.1 与运算（&lt;strong&gt;&amp;amp;&lt;/strong&gt;）&lt;/h3&gt;

&lt;p&gt;与运算：两个运算数比较位都是 1，则结果为 1，否则为 0。例如：&lt;code&gt;5 &amp;amp; 3 = 1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0101     5 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0011     3 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0001     换算成 10 进制为 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-或运算&#34;&gt;5.2 或运算（&lt;strong&gt;|&lt;/strong&gt;）&lt;/h3&gt;

&lt;p&gt;或运算：两个运算数比较位有一个为 1，则结果为 1，否则为 0。例如：&lt;code&gt;5 | 3 = 7&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0101     5 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0011     3 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0111     换算成 10 进制为 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-3-异或运算&#34;&gt;5.3 异或运算（&lt;strong&gt;^&lt;/strong&gt;）&lt;/h3&gt;

&lt;p&gt;异或运算：两个运算数比较位不同时，其结果是 1，否则为 0。例如：&lt;code&gt;5 ^ 3 = 6&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0101     5 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0011     3 转换为二进制
0000 0000 0000 0000 0000 0000 0000 0110     换算成 10 进制为 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-4-非运算&#34;&gt;5.4 非运算（&lt;strong&gt;~&lt;/strong&gt;）&lt;/h3&gt;

&lt;p&gt;非运算：也叫做补，一元运算符，对其运算数的每一位取反。例如：&lt;code&gt;~5 = -6&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0101     5 转换为二进制
1111 1111 1111 1111 1111 1111 1111 1010     取非后的原码
1000 0000 0000 0000 0000 0000 0000 0110     转换补码，换算成 10 进制为 -6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;六-其它&#34;&gt;六、其它&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java 中整数类型（byte、short、int 和 long）在内存中是以有符号的二进制补码表示。所以位运算时，首先要转换为原码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;补码转原码：补码转原码和原码转补码的方法是一样的，取反 + 1（补码的补码是原码）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当位运算数是 byte 和 short 类型时，将自动把这些类型扩大为 int 型（32 位）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算出 n 位二进制数所能表示的最大十进制数位移算法：&lt;code&gt;-1L ^ (-1L &amp;lt;&amp;lt; n)&lt;/code&gt; 或 &lt;code&gt;~(-1L &amp;lt;&amp;lt; 5)&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;byte 和 int 相互转换&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int i = 234;

byte b = (byte) i; // 结果：b = -22
// 转换过程：
// 0000 0000 0000 0000 0000 0000 1110 1010      # int 234 的补码（与原码相等）
//                               1110 1010      # byte 低位截取
//                               1001 0110      # 求得补码，转为 10 进制为 -22

int x = b ; // 结果为：x = -22；8 位 byte 的转 32 的 int，值不变。
int y = b &amp;amp; 0xff; // 结果为：x = 234； 可以通过将其和 0xff 进行位与（&amp;amp;）得到它的无符值
// 转换过程：
// 1001 0110                                    # byte -22 的原码
// 1000 0000 0000 0000 0000 0000 0001 0110      # int -22 的原码
// 1111 1111 1111 1111 1111 1111 1110 1010      # int -22 补码
// 0000 0000 0000 0000 0000 0000 1111 1111      # 0xff 的二进制数
// 0000 0000 0000 0000 0000 0000 1110 1010      # 和 0xff 进与操作的结果，转换为 10 进制为 234
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>SQL 事务隔离</title>
      <link>https://vxgo.github.io/2018/05/31/sql-transaction-isolation/</link>
      <pubDate>Thu, 31 May 2018 13:55:26 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/05/31/sql-transaction-isolation/</guid>
      <description>

&lt;p&gt;SQL 标准定义了 4 类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。&lt;/p&gt;

&lt;h2 id=&#34;一-sql-事务隔离级别说明&#34;&gt;一、SQL 事务隔离级别说明&lt;/h2&gt;

&lt;h3 id=&#34;1-1-read-uncommitted-读取未提交内容&#34;&gt;1.1 Read Uncommitted（读取未提交内容）&lt;/h3&gt;

&lt;p&gt;在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-2-read-committed-读取提交内容&#34;&gt;1.2 Read Committed（读取提交内容）&lt;/h3&gt;

&lt;p&gt;这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。&lt;/p&gt;

&lt;h3 id=&#34;1-3-repeatable-read-可重读&#34;&gt;1.3 Repeatable Read（可重读）&lt;/h3&gt;

&lt;p&gt;这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/p&gt;

&lt;h3 id=&#34;1-4-serializable-可串行化&#34;&gt;1.4 Serializable（可串行化）&lt;/h3&gt;

&lt;p&gt;这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。&lt;/p&gt;

&lt;h2 id=&#34;二-事务隔离带来的问题&#34;&gt;二、事务隔离带来的问题&lt;/h2&gt;

&lt;p&gt;这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：&lt;/p&gt;

&lt;h3 id=&#34;2-1-脏读-drity-read&#34;&gt;2.1 脏读（Drity Read）&lt;/h3&gt;

&lt;p&gt;一个事务读取到另一事务未提交的更新数据。当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中（这个数据在有可能会回滚），这时，另外一个事务也访问这个数据，然后使用了这个数据。&lt;/p&gt;

&lt;h3 id=&#34;2-2-不可重复读-non-repeatable-read&#34;&gt;2.2 不可重复读 (Non-repeatable read）&lt;/h3&gt;

&lt;p&gt;在一个事务内，前后两次读到的数据是不一样。在 T1 事务两次读取同一数据之间，T2 事务对该数据进行了修改，就会发生 T1 事务中的两次数据读取不一样的结果。相反， &lt;strong&gt;可重复读&lt;/strong&gt;：在同一事务中多次读取数据时，能够保证所读数据一样，也就是后续读取不能读到另一事务已提交的更新数据。&lt;/p&gt;

&lt;h3 id=&#34;2-3-幻读-phantom-read&#34;&gt;2.3 幻读 (Phantom Read）&lt;/h3&gt;

&lt;p&gt;指当事务不是独立执行时发生的一种现象，例如：T1 事务对表中的 &amp;ldquo;全部数据行&amp;rdquo; 进行了修改，同时 T2 事务向表中插入了一行 &amp;ldquo;新数据&amp;rdquo;，操作 T1 事务的用户发现表中&lt;strong&gt;还存在没有修改&lt;/strong&gt;的数据行，就好象发生了幻觉一 样。一般解决幻读的方法是增加范围锁 RangeS，锁定检锁范围为只读，这样就避免了幻读。&lt;/p&gt;

&lt;h3 id=&#34;2-4-不可重复读和幻读的异同&#34;&gt;2.4 不可重复读和幻读的异同&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;两者都表现为两次读取的结果不一致&lt;/li&gt;
&lt;li&gt;不可重复读是由于另一个事务对数据的更改所造成的，第二次读到了不一样的记录&lt;/li&gt;
&lt;li&gt;幻读是由于另一个事务插入或删除引起的，第二次查询的结果发生了变化&lt;/li&gt;
&lt;li&gt;对于不可重复读，只需要锁住满足条件的记录&lt;/li&gt;
&lt;li&gt;对于幻读，要锁住满足条件及其相近的记录&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;三-mysql-隔离级别&#34;&gt;三、MySQL 隔离级别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;隔离级别&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;脏读（Dirty Read）&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;不可重复读（NonRepeatable Read）&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;幻读（Phantom Read）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;未提交读（Read uncommitted）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;已提交读（Read committed）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;可重复读（Repeatable read）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;可串行化（SERIALIZABLE）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;四-mysql-事务隔离级别设置&#34;&gt;四、MySQL 事务隔离级别设置&lt;/h2&gt;

&lt;h3 id=&#34;4-1-innodb-默认是可重复读的-repeatable-read&#34;&gt;4.1 InnoDB 默认是可重复读的（REPEATABLE READ）&lt;/h3&gt;

&lt;p&gt;修改全局默认的事务级别，在 my.inf 文件的 [mysqld] 节里类似如下设置该选项（不推荐）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-2-改变单个会话或者所有新进连接的隔离级别-推荐使用&#34;&gt;4.2 改变单个会话或者所有新进连接的隔离级别（推荐使用）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-3-查询全局和会话事务隔离级别方法&#34;&gt;4.3 查询全局和会话事务隔离级别方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#查询全局的事务隔离级别
SELECT @@global.tx_isolation;
#查询当前会话的事务级别
SELECT @@session.tx_isolation;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JVM 运行时数据区域</title>
      <link>https://vxgo.github.io/2018/04/08/jvm-runtime-data-area/</link>
      <pubDate>Sun, 08 Apr 2018 17:30:33 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/04/08/jvm-runtime-data-area/</guid>
      <description>&lt;p&gt;Java 的内存区域划分绝不仅仅只是堆内存（heap）和栈内存（Stack），实际上 JVM 在执行 Java 程序的过程中会把它所管理的内存划分为以下几个数据区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区、运行时常量和直接内存。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/687148dbly1fq7bi09iazj21gf0ve0vv.jpg&#34; alt=&#34;Runtime DataArea&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-程序计数器-pc-register&#34;&gt;一、程序计数器（PC Register）&lt;/h2&gt;

&lt;p&gt;程序计数器（PC Register）是最小的一块内存区域，它的作用是记录正在执行的虚拟机字节码指令的地址。在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每一个 Java 线程都有一个程序计数器，用以记录比如在线程切换回来后恢复到正确的执行位置。&lt;/li&gt;
&lt;li&gt;如该线程正在执行一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码地址，如执行 Native 方法，则计数器值为空。&lt;/li&gt;
&lt;li&gt;此内存区域是唯一一个在 JVM 中没有规定任何 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 情况的区域。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-java-虚拟机栈-jvm-stacks&#34;&gt;二、Java 虚拟机栈（JVM Stacks）&lt;/h2&gt;

&lt;p&gt;每个 Java 方法在执行的同时会创建一个 &amp;ldquo;栈帧&amp;rdquo; 用于存储局部变量表（包括参数）、操作数栈（执行引擎计算时需要）、常量池引用、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。JVM 栈是线程私有的，并且生命周期与线程相同。并且当线程运行完毕后，相应内存也就被自动回收&lt;/p&gt;

&lt;p&gt;&lt;code&gt;局部变量表&lt;/code&gt; 存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（引用指针，并非对象本身），其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量的空间，其余数据类型只占 1 个。&lt;/p&gt;

&lt;p&gt;局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。&lt;/p&gt;

&lt;p&gt;可以通过虚拟机参数 &lt;code&gt;-Xss&lt;/code&gt;（例如：&lt;code&gt;java -Xss=512M HackTheJava&lt;/code&gt;）来指定一个程序的 Java 虚拟机栈内存大小。&lt;/p&gt;

&lt;p&gt;当线程请求的栈深度大于虚拟机所允许的深度，会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 异常（如：将一个函数反复递归自己，最终会出现这种异常）；如果 JVM 栈可以动态扩展（大部分 JVM 是可以的），当扩展时无法申请到足够内存，则会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h2 id=&#34;三-本地方法栈-native-method-stacks&#34;&gt;三、本地方法栈（Native Method Stacks）&lt;/h2&gt;

&lt;p&gt;本地方法不是用 Java 实现，对待这些方法需要特别处理。与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。和 JVM 栈一样，这个区域也会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 和 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h2 id=&#34;四-堆-heap&#34;&gt;四、堆（Heap）&lt;/h2&gt;

&lt;p&gt;堆（Heap）也叫做 Java 堆，GC 堆，是 Java 虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在 JVM 启动时创建。该内存区域存放了对象实例 (所有 new 的对象)及数组，JIT 编译器貌似不是这样的。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。&lt;/p&gt;

&lt;p&gt;其大小通过 &lt;code&gt;- Xms&lt;/code&gt;（最小值）和 &lt;code&gt;-Xmx&lt;/code&gt;（最大值）参数设置（例如：&lt;code&gt;java -Xms=1M -Xmx=2M HackTheJava&lt;/code&gt;），&lt;code&gt;-Xms&lt;/code&gt; 为 JVM 启动时申请的最小内存，默认为操作系统物理内存的 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;64&lt;/sub&gt; 但小于 1G，&lt;code&gt;-Xmx&lt;/code&gt; 为 JVM 可申请的最大内存，默认为物理内存的 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; 但小于 1G，默认当空余堆内存小于 40% 时，JVM 会增大 Heap 到 &lt;code&gt;-Xmx&lt;/code&gt; 指定的大小，可通过 &lt;code&gt;- XX:MinHeapFreeRation&lt;/code&gt; 来指定这个比列；当空余堆内存大于 70% 时，JVM 会减小 heap 的大小到 &lt;code&gt;-Xms&lt;/code&gt; 指定的大小，可通过 &lt;code&gt;XX:MaxHeapFreeRation&lt;/code&gt; 来指定这个比列，对于运行系统，为避免在运行时频繁调整 Heap 的大小，通常 &lt;code&gt;-Xms&lt;/code&gt; 与 &lt;code&gt;-Xmx&lt;/code&gt; 的值设成一样。&lt;/p&gt;

&lt;p&gt;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;p&gt;Java 堆是垃圾收集管理的主要战场，现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。&lt;/p&gt;

&lt;h3 id=&#34;4-1-新生代&#34;&gt;4.1 新生代&lt;/h3&gt;

&lt;p&gt;程序新创建的对象都是从新生代分配内存，新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：Eden、From Survivor、To Survivor。&lt;/p&gt;

&lt;p&gt;可通过 &lt;code&gt;- Xmn&lt;/code&gt; 参数来指定新生代的大小，也可以通过 &lt;code&gt;- XX:SurvivorRation&lt;/code&gt; 来调整 Eden Space 及 Survivor Space 的大小。&lt;/p&gt;

&lt;h3 id=&#34;4-2-老年代&#34;&gt;4.2 老年代&lt;/h3&gt;

&lt;p&gt;老年代用于存放经过多次新生代 GC 任然存活的对象，例如缓存对象。新建的对象也有可能直接进入老年代，主要有两种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大对象，可通过启动参数设置 &lt;code&gt;- XX:PretenureSizeThreshold=1024&lt;/code&gt;（单位为字节，默认为 0）来代表超过多大时就不在新生代分配，而是直接在老年代分配。&lt;/li&gt;
&lt;li&gt;大的数组对象，且数组中无引用外部对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老年代所占的内存大小为 &lt;code&gt;- Xmx&lt;/code&gt; 对应的值减去 &lt;code&gt;- Xmn&lt;/code&gt; 对应的值。&lt;/p&gt;

&lt;h3 id=&#34;4-3-永久代&#34;&gt;4.3 永久代&lt;/h3&gt;

&lt;p&gt;永久代是 Hotspot 虚拟机特有的概念，是方法区的一种实现，别的 JVM 都没有这个东西。在 Java 8 中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。
永久代或者 &amp;ldquo;Perm Gen&amp;rdquo; 包含了 JVM 需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是 Java 堆内存的一部分。永久代存放 JVM 运行时使用的类。永久代同样包含了 Java SE 库的类和方法。永久代的对象在 Full GC 时进行垃圾收集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/687148dbly1fq5ei22xlnj212u0petbs.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-方法区-method-area&#34;&gt;五、方法区（Method Area）&lt;/h2&gt;

&lt;p&gt;方法区（Method Area）也称 &amp;ldquo;永久代&amp;rdquo;、&amp;rdquo;非堆&amp;rdquo;，它用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，如：当程序中通过 getName、isInterface 等方法来获取信息时，这些数据来源于方法区。方法区是各个线程共享的内存区域，比如每个线程都可以访问同一个类的静态变量。默认最小值为 16MB，最大值为 64MB，可以通过 - XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。&lt;/p&gt;

&lt;p&gt;和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;p&gt;由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难，对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载。方法区并不等同于永久代，只是因为 HotSpot VM 使用永久代来实现方法区，对于其他的 Java 虚拟机，比如 J9 和 JRockit 等，并不存在永久代概念。&lt;/p&gt;

&lt;h2 id=&#34;六-运行时常量池-runtime-constant-pool&#34;&gt;六、运行时常量池（Runtime Constant Pool）&lt;/h2&gt;

&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分，值得注意的是 JDK1.7 已经把常量池转移到堆里面了。Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。运行时常量池可以理解为是类或接口的常量池的运行时表现形式。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。&lt;/p&gt;

&lt;p&gt;当创建类或接口时，如果构造运行时常量池所需的内存超过了方法区所能提供的最大值，Java 虚拟机会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h2 id=&#34;七-直接内存-direct-memory&#34;&gt;七、直接内存（Direct Memory）&lt;/h2&gt;

&lt;p&gt;在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。&lt;/p&gt;

&lt;hr /&gt;

&lt;!-- [1]: /images/post/jvm-runtime-data-area.png
[2]: /images/post/20180408-175834.png --&gt;</description>
    </item>
    
    <item>
      <title>Mac 实用小工具</title>
      <link>https://vxgo.github.io/2018/03/30/mac-utility-tools/</link>
      <pubDate>Fri, 30 Mar 2018 20:45:40 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/03/30/mac-utility-tools/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;记录备忘一下 Mac 系统下一些实用的小工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;收费&#34;&gt;收费&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bartender&lt;/code&gt; : 菜单栏管理工具，可以将菜单放进 Bartender 的二级菜单&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SizeUp&lt;/code&gt; : 实用分屏小工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxifier&lt;/code&gt; :  配合 ss/ssr 可以实现真正的全局代理软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iStat Menus&lt;/code&gt; : 能够在系统菜单栏实时监控 CPU、内存、硬盘、网络、温度、电池以及系统时间等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CleanMyMac&lt;/code&gt; : 系统清理工具，可以清除 mac 系统多余的语言包、系统缓存、应用程序等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyCue&lt;/code&gt; : 快捷键辅助工具，忘记一些快捷键的时候按住 Command 就会出现快捷键大全的菜单&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Araxis Merge&lt;/code&gt; : 可视化文件合并以及数据同步工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;免费&#34;&gt;免费&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Alfred&lt;/code&gt; : Mac 效率神器，Spotlight 完美替代产品（需要付费购买部分功能）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iTerm2&lt;/code&gt; : 是一款完全免费的，专为 Mac OS 用户打造的命令行应用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Typora&lt;/code&gt; : 极致简洁的 markdown 编辑器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kap&lt;/code&gt; : 免费开源的屏幕录像软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Karabiner Elements&lt;/code&gt; : 修改键位映射软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Gas Mask&lt;/code&gt; : 免费开源的 hosts 管理软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeePassX&lt;/code&gt; : 免费开源的密码管理软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Keka&lt;/code&gt; : 丑到极致的压缩、解压软件（不换图标不忍直视）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dr. Unarchiver&lt;/code&gt; : 功能强大的解压软件&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>漂 泊</title>
      <link>https://vxgo.github.io/2018/03/10/drifter/</link>
      <pubDate>Sat, 10 Mar 2018 23:02:47 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/03/10/drifter/</guid>
      <description>&lt;blockquote class=&#39;blockquote-center&#39;&gt; 北漂，是一种选择，但越来越多的会是无奈和彷徨，
踌躇满志而来，万念俱灰而归，也许就是大多数北漂的归属，结局也许有些夸张。
最终，我还是无法爱上这座城市，最起码我努力爱过...
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/687148dbgy1fp8q20yzt6g206y046x0m.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;月底又要搬家了，刚对一个地方稍微熟悉，就又要换一个地了，来北京这么多年，一年换一个地，行李越来越多，心情越来越不是滋味&amp;hellip;漂泊的人啊，怎样才能有一颗不流浪的心！&lt;/p&gt;

&lt;p&gt;也许真是老了，伤感越来越多，前段时间经历了一次彻头彻尾失败的面试，对未来的工作越来越没自信，危机感油然而生，快要被淘汰了哦！在绝境中获得反省，希望能够被铭记&amp;hellip;&lt;/p&gt;

&lt;p&gt;夜幕降临，希望每一位 Beijing Drifter 都能够安然入睡，梦回故里，第二天醒来依然对这个城市充满爱。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;!-- [1]: /images/post/bj-20180311.gif --&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 反射使用总结</title>
      <link>https://vxgo.github.io/2018/01/26/golang-reflect/</link>
      <pubDate>Fri, 26 Jan 2018 21:27:56 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/01/26/golang-reflect/</guid>
      <description>&lt;p&gt;Go 语言中反射的操作主要定义在标准库 &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; 中，在标准库中定义了两种类型来表现运行时的对象信息，分别是：&lt;a href=&#34;https://golang.org/pkg/reflect/#Value&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;reflect.Value&lt;/code&gt;&lt;/a&gt;（反射对象的类型）和 &lt;a href=&#34;https://golang.org/pkg/reflect/#Type&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;reflect.Type&lt;/code&gt;&lt;/a&gt;（反射对象的值），Go 语言中所有反射操作都是基于这两个类型进行的。&lt;/p&gt;

&lt;!-- {% img https://ws1.sinaimg.cn/large/687148dbly1fo6mhg1xw3j20mf0c10v1.jpg 350 %} --&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/687148dbly1fo6mhg1xw3j20mf0c10v1.jpg&#34; alt=&#34;golang-reflect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了方便演示操作（&lt;a href=&#34;https://github.com/ehlxr/go-utils/blob/master/common/reflect/main.go&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;完整代码示例&lt;/a&gt;），首先定义以下结构体以及字段、方法：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type User struct {
    Name string `json:&amp;quot;name&amp;quot;`
    Age  int    `json:&amp;quot;age&amp;quot; default:&amp;quot;18&amp;quot;`
    addr string `json:&amp;quot;addr&amp;quot;`
}

func (u User) Do(in string) (string, int) {
    fmt.Printf(&amp;quot;%s Name is %s, Age is %d \n&amp;quot;, in, u.Name, u.Age)
    return u.Name, u.Age
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一-反射对象-value-和-type&#34;&gt;一、反射对象 Value 和 Type&lt;/h2&gt;

&lt;p&gt;既然 Go 语言中所有反射操作都是基于 &lt;code&gt;Value&lt;/code&gt; 和 &lt;code&gt;Type&lt;/code&gt; 进行的，那么想要进行反射操作，首先就要获取到反射对象的这两个类型对象才可以。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reflect&lt;/code&gt; 包提供了两个函数：&lt;code&gt;reflect.ValueOf()&lt;/code&gt; 和 &lt;code&gt;reflect.TypeOf()&lt;/code&gt;，通过这两个函数就可以方便的获取到任意类型（用 &lt;code&gt;interface{}&lt;/code&gt; 表示任意类型）的 &lt;code&gt;Value&lt;/code&gt; 对象和 &lt;code&gt;Type&lt;/code&gt; 对象。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;u := User{&amp;quot;tom&amp;quot;, 27, &amp;quot;beijing&amp;quot;}

v := reflect.ValueOf(u)
fmt.Println(v)

t := reflect.TypeOf(u)
fmt.Println(t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道 &lt;code&gt;Value&lt;/code&gt; 对象后，也可以通过 &lt;code&gt;Value.Type()&lt;/code&gt; 方法获取到 &lt;code&gt;Type&lt;/code&gt; 对象。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;t1 := v.Type()
fmt.Println(t == t1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到输出结果为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;Type&lt;/code&gt; 类型对象也可以获取到 &lt;code&gt;Value&lt;/code&gt; 类型对象，不过是零值的指针。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;v1 := reflect.New(t)
fmt.Println(v1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为：&lt;code&gt;&amp;amp;{ 0}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-反射对象的-kind&#34;&gt;二、反射对象的 Kind&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt; 表示反射对象的类型 &lt;code&gt;Type&lt;/code&gt; 所代表的具体类型，零值表示无效的类型，具体有以下类型值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Kind uint

const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过 &lt;code&gt;Value.Kind()&lt;/code&gt; 或者 &lt;code&gt;Type.Kind()&lt;/code&gt; 函数获得。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 获取 Kind 类型
k := t.Kind()
fmt.Println(k)
k1 := v.Kind()
fmt.Println(k1)
fmt.Println(k == k1)
fmt.Println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到两种方式获取的结果是一样的，都是 &lt;code&gt;struct&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;三-反射对象的字段&#34;&gt;三、反射对象的字段&lt;/h2&gt;

&lt;p&gt;反射能够操作的字段和方法必须是可导出（首字母大写）的。&lt;/p&gt;

&lt;p&gt;反射对象的字段值修改要通过调用 &lt;code&gt;Value&lt;/code&gt; 类型的方法 &lt;code&gt;Elem()&lt;/code&gt; 后返回的 &lt;code&gt;Value&lt;/code&gt; 对象值来操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Elem()&lt;/code&gt; 方法定义：&lt;code&gt;func (v Value) Elem() Value&lt;/code&gt;，返回 &lt;code&gt;v&lt;/code&gt; 包含的值或指针 &lt;code&gt;v&lt;/code&gt; 指向的值，&lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;Kind&lt;/code&gt; 如果不是 &lt;code&gt;Interface&lt;/code&gt; 或 &lt;code&gt;Ptr&lt;/code&gt;，则会 panic。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reflect.Indirect()&lt;/code&gt; 函数的如果参数是指针的 &lt;code&gt;Value&lt;/code&gt;，则相当于调用了 &lt;code&gt;Elem()&lt;/code&gt; 方法返回的值，否则返回 &lt;code&gt;Value&lt;/code&gt; 自身值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 修改反射对象的值
i := 20
fmt.Println(&amp;quot;before i =&amp;quot;, i)
e := reflect.Indirect(reflect.ValueOf(&amp;amp;i))
// e := reflect.ValueOf(&amp;amp;i).Elem()
if e.CanSet() {
    e.SetInt(22)
}
fmt.Println(&amp;quot;after i =&amp;quot;, i)


// 反射字段操作
// elem := reflect.Indirect(reflect.ValueOf(&amp;amp;u))
elem := reflect.ValueOf(&amp;amp;u).Elem()
for i := 0; i &amp;lt; t.NumField(); i++ {
    // 反射获取字段的元信息，例如：名称、Tag 等
    ft := t.Field(i)
    fmt.Println(&amp;quot;field name:&amp;quot;, ft.Name)
    tag := ft.Tag
    fmt.Println(&amp;quot;Tag:&amp;quot;, tag)
    fmt.Println(&amp;quot;Tag json:&amp;quot;, tag.Get(&amp;quot;json&amp;quot;))

    // 反射修改字段的值
    fv := elem.Field(i)
    if fv.CanSet() {
        if fv.Kind() == reflect.Int {
            fmt.Println(&amp;quot;change age to 30&amp;quot;)
            fv.SetInt(30)
        }
        if fv.Kind() == reflect.String {
            fmt.Println(&amp;quot;change name to jerry&amp;quot;)
            fv.SetString(&amp;quot;jerry&amp;quot;)
        }
    }
    fmt.Println()
}
fmt.Println(&amp;quot;after user:&amp;quot;, u)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-反射对象的方法&#34;&gt;四、反射对象的方法&lt;/h2&gt;

&lt;p&gt;可以通过 &lt;code&gt;Value&lt;/code&gt; 的 &lt;code&gt;Method()&lt;/code&gt; 方法或 &lt;code&gt;Type&lt;/code&gt; 的 &lt;code&gt;Method()&lt;/code&gt; 方法，两种形式获取对象方法信息进行反射调用，略有不同，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 反射方法操作
for i := 0; i &amp;lt; v.NumMethod(); i++ {
    method := t.Method(i) // 获取方法信息对象，方法 1
    mt := method.Type     // 获取方法信息 Type 对象，方法 1

    // m := v.Method(i) // 获取方法信息对象，方法 2
    // mt := m.Type()   // 获取方法信息 Type 对象，方法 2

    fmt.Println(&amp;quot;method name:&amp;quot;, method.Name)

    in := []reflect.Value{}

    // 获取方法入参类型
    for j := 0; j &amp;lt; mt.NumIn(); j++ {
        fmt.Println(&amp;quot;method in type:&amp;quot;, mt.In(j))
        if mt.In(j).Kind() == reflect.String {
            in = append(in, reflect.ValueOf(&amp;quot;welcome&amp;quot;))
        }
        // 方法 1 获取的方法信息对象会把方法的接受者也当着入参之一
        if mt.In(j).Name() == t.Name() {
            in = append(in, v)
        }
    }

    // 获取方法返回类型
    for j := 0; j &amp;lt; mt.NumOut(); j++ {
        fmt.Println(&amp;quot;method out type:&amp;quot;, mt.Out(j))
    }

    // 反射方法调用
    // out := m.Call(in) // 方法 1 获取的 Method 对象反射调用方式
    out := method.Func.Call(in) // 方法 1 获取的 Method 对象反射调用方式
    for _, o := range out {
        fmt.Println(&amp;quot;out:&amp;quot;, o)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-反射对象-value-还原&#34;&gt;五、反射对象 Value 还原&lt;/h2&gt;

&lt;p&gt;通过 &lt;code&gt;reflect.ValueOf()&lt;/code&gt; 可以把任意类型对象转换为 &lt;code&gt;Value&lt;/code&gt; 类型对象，也可以通过 &lt;code&gt;Value&lt;/code&gt; 类型的方法 &lt;code&gt;Interface()&lt;/code&gt; 把 &lt;code&gt;Value&lt;/code&gt; 类型对象还原为原始数据类型对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Value 转原始类型
if u1, ok := v.Interface().(User); ok {
    fmt.Println(&amp;quot;after:&amp;quot;, u1.Name, u1.Age)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- [1]: /images/post/golang-reflect.jpg --&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 学习笔记之 MiniKube 安装</title>
      <link>https://vxgo.github.io/2018/01/12/kubernetes-minikube-installation/</link>
      <pubDate>Fri, 12 Jan 2018 09:23:01 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2018/01/12/kubernetes-minikube-installation/</guid>
      <description>&lt;p&gt;Kubernetes 集群的搭建是有一定难度的，尤其是对于初学者来说，好多概念和原理不懂，即使有现成的教程也会出现很多不可预知的问题，很容易打击学习的积极性，就此弃坑。好在 Kubernetes 社区提供了可以在本地开发和体验的极简集群安装 MiniKube，对于入门学习来说很方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/687148dbly1fo7n00rkl6j20b40b4goj.jpg&#34; alt=&#34;minikube&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MiniKube 官方安装介绍已经非常详细了，可以参考 &lt;a href=&#34;https://github.com/kubernetes/minikube#installation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;installation&lt;/a&gt;。但是在国内由于网络访问原因（懂的），即使有梯子也很折腾，所以记录一下阿里修改后的 MiniKube 安装。使用阿里修改后的 MiniKube 就可以从阿里云的镜像地址来获取所需 Docker 镜像和配置，其它的并没有差异，下文着重介绍。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-kubectl-安装&#34;&gt;一、kubectl 安装&lt;/h2&gt;

&lt;p&gt;MiniKube 的安装需要先安装 kubectl 及相关驱动，这没什么好说的，参考&lt;a href=&#34;https://github.com/kubernetes/minikube#requirements&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方介绍&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;另 kubectl 也可通过源代码编译安装，编译源码需要有 Git、Golang 环境的支撑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ git clone https://github.com/kubernetes/kubernetes.git
➜ cd kubernetes
➜ make
➜ sudo cp _output/bin/kubectl /usr/local/bin/
➜ sudo chmod +x /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-minikube-安装&#34;&gt;二、MiniKube 安装&lt;/h2&gt;

&lt;p&gt;MiniKube 是使用 Go 语言开发的，所以安装其实很方便，一是通过下载基于不同平台早已编译好的二级制文件安装，二是可以编译源文件安装。&lt;/p&gt;

&lt;h3 id=&#34;2-1-二级制文件安装&#34;&gt;2.1 二级制文件安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Mac OSX 平台&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜ curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.24.1/minikube-darwin-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Linux 平台&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜ curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.24.1/minikube-linux-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Windows 平台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载 &lt;a href=&#34;http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.24.1/minikube-windows-amd64.exe&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;minikube-windows-amd64.exe&lt;/a&gt; 文件，并重命名为 &lt;code&gt;minikube.exe&lt;/code&gt;，然后加入到环境变量路径下即可。&lt;/p&gt;

&lt;h3 id=&#34;2-2-源码编译安装&#34;&gt;2.2 源码编译安装&lt;/h3&gt;

&lt;p&gt;编译源码需要有 Git、Golang 环境的支撑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ git clone https://github.com/AliyunContainerService/minikube
➜ cd minikube
➜ git checkout aliyun-v0.24.1
➜ make
➜ sudo cp out/minikube /usr/local/bin/
➜ sudo chmod +x /usr/local/bin/minikube
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;示例版本是 &lt;code&gt;v0.24.1&lt;/code&gt;，可更改为&lt;a href=&#34;https://github.com/AliyunContainerService/minikube/branches/all&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;其它版本&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;三-简单使用&#34;&gt;三、简单使用&lt;/h2&gt;

&lt;h3 id=&#34;3-1-启动&#34;&gt;3.1 启动&lt;/h3&gt;

&lt;p&gt;默认启动使用的是 VirtualBox 驱动，使用 &lt;code&gt;--vm-driver&lt;/code&gt; 参数可以指定其它驱动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置 docker 加速镜像
➜ minikube start --registry-mirror=https://registry.docker-cn.com
Starting local Kubernetes v1.8.0 cluster...
Starting VM...
Getting VM IP address...
Moving files into cluster...
Setting up certs...
Connecting to cluster...
Setting up kubeconfig...
Starting cluster components...
Kubectl is now configured to use the cluster.
Loading cached images from config file.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-检测状态&#34;&gt;3.2 检测状态&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ minikube status
minikube: Running
cluster: Running
kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-启动-kubernetes-dashboard&#34;&gt;3.3 启动 kubernetes dashboard&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ minikube dashboard
Opening kubernetes dashboard in default browser...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入以上命令，浏览器中应该就会显示以下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/687148dbly1fndlyb1kpuj227s1ain5a.jpg&#34; alt=&#34;minikube-dashboard&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-4-测试&#34;&gt;3.4 测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;运行一个 nginx 的 pod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ kubectl run hello --image=nginx --port=80
deployment &amp;quot;hello&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;导出运行的 nginx 服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ kubectl expose deployment hello --type=NodePort
service &amp;quot;hello&amp;quot; exposed
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看一下运行情况，需要等一会才会显示状态为 &lt;code&gt;Running&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ kubectl get pod
NAME                    READY     STATUS    RESTARTS   AGE
hello-6dbbbb95d-4cqwz   1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;curl 访问测试&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ curl $(minikube service hello --url)
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-5-其它&#34;&gt;3.5 其它&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看集群的所有资源
➜ kubectl get all
➜ kubectl get all -o wide

# 进入节点服务器
➜ minikube ssh

# 执行节点服务器命令，例如查看节点 docker info
➜ minikube ssh -- docker info

# 删除集群
➜ minikube delete

# 关闭集群
➜ minikube stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/221687&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Minikube - Kubernetes本地实验环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;!-- [1]: /images/post/minikube.jpg --&gt;

&lt;!-- [2]: /images/post/minikube-dashboard.jpg --&gt;</description>
    </item>
    
    <item>
      <title>又是一年岁末时...</title>
      <link>https://vxgo.github.io/2017/12/31/summary-in-2017/</link>
      <pubDate>Sun, 31 Dec 2017 11:52:58 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2017/12/31/summary-in-2017/</guid>
      <description>&lt;p&gt;2017 年最后一天了，北京的天气很好，阳光明媚，关键是没有雾霾。说起雾霾，今年北京可是&amp;rdquo;治理&amp;rdquo;的很有效果，截止目前雾霾天和去年的好天气一样多，买了个空气净化器还没怎么派上用场，哈哈。&lt;/p&gt;

&lt;p&gt;步入了婚姻的殿堂，享受幸福的同是多了一份责任。进入人生下一个阶段，需要处理的关系更多，新的一年需要勉励自己不断前行&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/687148dbly1fodlad6j39g20dw06i4qp.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;奋斗在一线的程序猿，到了一定的阶段，就不得不审视一下自己的未来。作为碌碌无为低端程序猿的我，此刻对未来感到深深的迷茫。少了年少时的拼劲，多了肩膀上的重担，不知作为下一个低端人群的我在北京还能拼搏多久。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;更为可悲的是，每当危机到来的时候才发觉自己已经快退化的让自己害怕了，偶尔看到一句话：“六年开发经验？还是学习了一年，重复工作了五年”，值得深思。&lt;/p&gt;

&lt;p&gt;2017 已经逝去，2018 任道而重远&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;!-- [1]: https://ws1.sinaimg.cn/large/687148dbly1fn20sekpb2j20qq0hqqib.jpg --&gt;
  &lt;!-- [1]: /images/post/20180102.jpg --&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 常用代码块</title>
      <link>https://vxgo.github.io/2017/12/06/go-commons-code-snippets/</link>
      <pubDate>Wed, 06 Dec 2017 10:07:54 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2017/12/06/go-commons-code-snippets/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;总结备忘一下常用的的 Go 代码片段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;遍历目录下的文件&#34;&gt;遍历目录下的文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getFilelist(r string) {
    err := filepath.Walk(r, func(p string, f os.FileInfo, err error) error {
        if f == nil {
            return nil
        }
        if p == r || f.IsDir() {
            return nil
        }
        fmt.Println(p)
        return nil
    })
    if err != nil {
        fmt.Printf(&amp;quot;filepath.Walk() returned %v\n&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;定时器&#34;&gt;定时器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duration := 2 * time.Second
timer := time.NewTimer(duration)
go func() {
    for {
        select {
        case &amp;lt;-timer.C:
            fmt.Println(&amp;quot;here&amp;quot;)
            timer.Reset(duration)
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定时执行任务&#34;&gt;定时执行任务&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

const INTERVAL_PERIOD time.Duration = 24 * time.Hour

const HOUR_TO_TICK int = 23
const MINUTE_TO_TICK int = 00
const SECOND_TO_TICK int = 03

func main() {
    ticker := updateTicker()
    for {
        &amp;lt;-ticker.C
        fmt.Println(time.Now(), &amp;quot;- just ticked&amp;quot;)
        ticker = updateTicker()
    }
}

func updateTicker() *time.Ticker {
    n := time.Date(time.Now().Year(), time.Now().Month(), time.Now().Day(),
        HOUR_TO_TICK, MINUTE_TO_TICK, SECOND_TO_TICK, 0, time.Local)

    if !n.After(time.Now()) {
        n = n.Add(INTERVAL_PERIOD)
    }
    fmt.Println(n, &amp;quot;- next tick&amp;quot;)
    diff := n.Sub(time.Now())
    return time.NewTicker(diff)
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;读取文件&#34;&gt;读取文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(&amp;quot;/test.txt&amp;quot;)
if err != nil {
    panic(err)
}
defer f.Close()
fd, err := ioutil.ReadAll(f)
if err != nil {
    panic(err)
}
fmt.Println(string(fd))

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;map-转-json&#34;&gt;map 转 json&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := make(map[string]interface{})
m[&amp;quot;show&amp;quot;] = &amp;quot;1&amp;quot;
m[&amp;quot;content&amp;quot;] = &amp;quot;test&amp;quot;
j, err := json.Marshal(m)
if err != nil {
    panic(err)
}
fmt.Println(string(j))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json-转-map&#34;&gt;json 转 map&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var result = []byte(`
{
    &amp;quot;show&amp;quot;: 1,
    &amp;quot;content&amp;quot;: &amp;quot;test&amp;quot;
}`)

var r map[string]interface{}
if err := json.Unmarshal(result, &amp;amp;r); err != nil {
    panic(err)
}
fmt.Println(r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;写文件&#34;&gt;写文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func writeFile(path string, b []byte) {
    file, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0777)
    defer file.Close()

    if err != nil {
        panic(err)
    }

    file.Write(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;简单的获取-ip&#34;&gt;简单的获取 IP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetPulicIP() string {
    conn, _ := net.Dial(&amp;quot;udp&amp;quot;, &amp;quot;8.8.8.8:80&amp;quot;)
    defer conn.Close()
    localAddr := conn.LocalAddr().String()
    idx := strings.LastIndex(localAddr, &amp;quot;:&amp;quot;)
    return localAddr[0:idx]
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[转]Tmux 快捷键速查表</title>
      <link>https://vxgo.github.io/2017/10/25/tmux-cheat-sheet/</link>
      <pubDate>Wed, 25 Oct 2017 14:45:24 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2017/10/25/tmux-cheat-sheet/</guid>
      <description>&lt;h1 id=&#34;tmux-快捷键-速查表&#34;&gt;Tmux 快捷键 &amp;amp; 速查表&lt;/h1&gt;

&lt;p&gt;启动新会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux [new -s 会话名 -n 窗口名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux at [-t 会话名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;killSessions&#34;&gt;&lt;/a&gt;关闭会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux kill-session -t 会话名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;killAllSessions&#34;&gt;&lt;/a&gt;关闭所有会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux ls | grep : | cut -d. -f1 | awk &#39;{print substr($1, 0, length($1)-1)}&#39; | xargs kill
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;在-tmux-中-按下-tmux-前缀-ctrl-b-然后&#34;&gt;在 Tmux 中，按下 Tmux 前缀 &lt;code&gt;ctrl+b&lt;/code&gt;，然后：&lt;/h1&gt;

&lt;h2 id=&#34;会话&#34;&gt;会话&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;:new&amp;lt;回车&amp;gt;  启动新会话
s           列出所有会话
$           重命名当前会话
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-windowstabs-a-窗口-标签页&#34;&gt;&lt;a name=&#34;WindowsTabs&#34;&gt;&lt;/a&gt;窗口 (标签页)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;c  创建新窗口
w  列出所有窗口
n  后一个窗口
p  前一个窗口
f  查找窗口
,  重命名当前窗口
&amp;amp;  关闭当前窗口
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;调整窗口排序&#34;&gt;调整窗口排序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;swap-window -s 3 -t 1  交换 3 号和 1 号窗口
swap-window -t 1       交换当前和 1 号窗口
move-window -t 1       移动当前窗口到 1 号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-panessplits-a-窗格-分割窗口&#34;&gt;&lt;a name=&#34;PanesSplits&#34;&gt;&lt;/a&gt;窗格（分割窗口）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%  垂直分割
&amp;quot;  水平分割
o  交换窗格
x  关闭窗格
⍽  左边这个符号代表空格键 - 切换布局
q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格
{ 与上一个窗格交换位置
} 与下一个窗格交换位置
z 切换窗格最大化/最小化
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-syncpanes-a-同步窗格&#34;&gt;&lt;a name=&#34;syncPanes&#34;&gt;&lt;/a&gt;同步窗格&lt;/h2&gt;

&lt;p&gt;这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:setw synchronize-panes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以指定开或关，否则重复执行命令会在两者间切换。
这个选项值针对某个窗口有效，不会影响别的会话和窗口。
完事儿之后再次执行命令来关闭。&lt;a href=&#34;http://blog.sanctum.geek.nz/sync-tmux-panes/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;帮助&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;调整窗格尺寸&#34;&gt;调整窗格尺寸&lt;/h2&gt;

&lt;p&gt;如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PREFIX : resize-pane -D          当前窗格向下扩大 1 格
PREFIX : resize-pane -U          当前窗格向上扩大 1 格
PREFIX : resize-pane -L          当前窗格向左扩大 1 格
PREFIX : resize-pane -R          当前窗格向右扩大 1 格
PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格
PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文本复制模式&#34;&gt;文本复制模式：&lt;/h2&gt;

&lt;p&gt;按下&lt;strong&gt;前缀 [&lt;/strong&gt;进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setw -g mode-keys vi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启用这条配置后，就可以使用 h、j、k、l 来移动光标了。&lt;/p&gt;

&lt;p&gt;想要退出文本复制模式的话，按下回车键就可以了。一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。&lt;/p&gt;

&lt;p&gt;例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi             emacs        功能
^              M-m          反缩进
Escape         C-g          清除选定内容
Enter          M-w          复制选定内容
j              Down         光标下移
h              Left         光标左移
l              Right        光标右移
L                           光标移到尾行
M              M-r          光标移到中间行
H              M-R          光标移到首行
k              Up           光标上移
d              C-u          删除整行
D              C-k          删除到行末
$              C-e          移到行尾
:              g            前往指定行
C-d            M-Down       向下滚动半屏
C-u            M-Up         向上滚动半屏
C-f            Page down    下一页
w              M-f          下一个词
p              C-y          粘贴
C-b            Page up      上一页
b              M-b          上一个词
q              Escape       退出
C-Down or J    C-Down       向下翻
C-Up or K      C-Up         向下翻
n              n            继续搜索
?              C-r          向前搜索
/              C-s          向后搜索
0              C-a          移到行首
Space          C-Space      开始选中
               C-t          字符调序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;杂项&#34;&gt;杂项：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;d  退出 tmux（tmux 仍在后台运行）
t  窗口中央显示一个数字时钟
?  列出所有快捷键
:  命令提示符
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置选项&#34;&gt;配置选项：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 鼠标支持 - 设置为 on 来启用鼠标
* setw -g mode-mouse off
* set -g mouse-select-pane off
* set -g mouse-resize-pane off
* set -g mouse-select-window off

# 设置默认终端模式为 256color
set -g default-terminal &amp;quot;screen-256color&amp;quot;

# 启用活动警告
setw -g monitor-activity on
set -g visual-activity on

# 居中窗口列表
set -g status-justify centre

# 最大化/恢复窗格
unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmp
unbind Down
bind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置文件-tmux-conf&#34;&gt;配置文件（~/.tmux.conf）：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 基础设置
set -g default-terminal &amp;quot;screen-256color&amp;quot;
set -g display-time 3000
set -g escape-time 0
set -g history-limit 65535
set -g base-index 1
set -g pane-base-index 1

# 前缀绑定 (Ctrl+a)
set -g prefix ^a
unbind ^b
bind a send-prefix

# 分割窗口
unbind &#39;&amp;quot;&#39;
bind - splitw -v
unbind %
bind | splitw -h

# 选中窗口
bind-key k select-pane -U
bind-key j select-pane -D
bind-key h select-pane -L
bind-key l select-pane -R

# copy-mode 将快捷键设置为 vi 模式
setw -g mode-keys vi

# 启用鼠标(Tmux v2.1)
set -g mouse on

# 更新配置文件
bind r source-file ~/.tmux.conf \; display &amp;quot;已更新&amp;quot;

#&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
# Tmux Plugin Manager(Tmux v2.1)
# Tmux Resurrect
set -g @plugin &#39;tmux-plugins/tmux-resurrect&#39;

# List of plugins
set -g @plugin &#39;tmux-plugins/tpm&#39;
set -g @plugin &#39;tmux-plugins/tmux-sensible&#39;

# Other examples:
# set -g @plugin &#39;github_username/plugin_name&#39;
# set -g @plugin &#39;git@github.com/user/plugin&#39;
# set -g @plugin &#39;git@bitbucket.com/user/plugin&#39;

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run &#39;~/.tmux/plugins/tpm/tpm&#39;
#&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/ryerh/14b7c24dfd623ef8edc7&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;原文地址&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[转] Go Cheat Sheet</title>
      <link>https://vxgo.github.io/2017/08/24/golang-cheat-sheet/</link>
      <pubDate>Thu, 24 Aug 2017 14:18:53 +0000</pubDate>
      
      <guid>https://vxgo.github.io/2017/08/24/golang-cheat-sheet/</guid>
      <description>&lt;h1 id=&#34;go-cheat-sheet&#34;&gt;Go Cheat Sheet&lt;/h1&gt;

&lt;h2 id=&#34;credits&#34;&gt;Credits&lt;/h2&gt;

&lt;p&gt;Most example code taken from &lt;a href=&#34;http://tour.golang.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;A Tour of Go&lt;/a&gt;, which is an excellent introduction to Go.
If you&amp;rsquo;re new to Go, do that tour. Seriously.&lt;/p&gt;

&lt;h2 id=&#34;go-in-a-nutshell&#34;&gt;Go in a Nutshell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Imperative language&lt;/li&gt;
&lt;li&gt;Statically typed&lt;/li&gt;
&lt;li&gt;Syntax tokens similar to C (but less parentheses and no semicolons) and the structure to Oberon-2&lt;/li&gt;
&lt;li&gt;Compiles to native code (no JVM)&lt;/li&gt;
&lt;li&gt;No classes, but structs with methods&lt;/li&gt;
&lt;li&gt;Interfaces&lt;/li&gt;
&lt;li&gt;No implementation inheritance. There&amp;rsquo;s &lt;a href=&#34;http://golang.org/doc/effective%5Fgo.html#embedding&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;type embedding&lt;/a&gt;, though.&lt;/li&gt;
&lt;li&gt;Functions are first class citizens&lt;/li&gt;
&lt;li&gt;Functions can return multiple values&lt;/li&gt;
&lt;li&gt;Has closures&lt;/li&gt;
&lt;li&gt;Pointers, but not pointer arithmetic&lt;/li&gt;
&lt;li&gt;Built-in concurrency primitives: Goroutines and Channels&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;basic-syntax&#34;&gt;Basic Syntax&lt;/h1&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;File &lt;code&gt;hello.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello Go&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ go run hello.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;operators&#34;&gt;Operators&lt;/h2&gt;

&lt;h3 id=&#34;arithmetic&#34;&gt;Arithmetic&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;addition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;subtraction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;multiplication&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;quotient&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;remainder&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bitwise and&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bitwise or&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bitwise xor&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bit clear (and not)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;left shift&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;right shift&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; -&amp;gt; &lt;code&gt;|&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;comparison&#34;&gt;Comparison&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;not equal&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;less than&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;less than or equal&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;greater than&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;greater than or equal&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;logical&#34;&gt;Logical&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;logical and&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;??&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;logical or&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;logical not&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;??&lt;/code&gt; -&amp;gt; &lt;code&gt;||&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;other&#34;&gt;Other&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;address of / create pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;dereference pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;send / receive operator (see &amp;lsquo;Channels&amp;rsquo; below)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;declarations&#34;&gt;Declarations&lt;/h2&gt;

&lt;p&gt;Type goes after identifier!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var foo int // declaration without initialization
var foo int = 42 // declaration with initialization
var foo, bar int = 42, 1302 // declare and init multiple vars at once
var foo = 42 // type omitted, will be inferred
foo := 42 // shorthand, only in func bodies, omit var keyword, type is always implicit
const constant = &amp;quot;This is a constant&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// a simple function
func functionName() {}

// function with parameters (again, types go after identifiers)
func functionName(param1 string, param2 int) {}

// multiple parameters of the same type
func functionName(param1, param2 int) {}

// return type declaration
func functionName() int {
    return 42
}

// Can return multiple values at once
func returnMulti() (int, string) {
    return 42, &amp;quot;foobar&amp;quot;
}
var x, str = returnMulti()

// Return multiple named results simply by return
func returnMulti2() (n int, s string) {
    n = 42
    s = &amp;quot;foobar&amp;quot;
    // n and s will be returned
    return
}
var x, str = returnMulti2()

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functions-as-values-and-closures&#34;&gt;Functions As Values And Closures&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    // assign a function to a name
    add := func(a, b int) int {
        return a + b
    }
    // use the name to call the function
    fmt.Println(add(3, 4))
}

// Closures, lexically scoped: Functions can access values that were
// in scope when defining the function
func scope() func() int{
    outer_var := 2
    foo := func() int { return outer_var}
    return foo
}

func another_scope() func() int{
    // won&#39;t compile because outer_var and foo not defined in this scope
    outer_var = 444
    return foo
}


// Closures: don&#39;t mutate outer vars, instead redefine them!
func outer() (func() int, int) {
    outer_var := 2
    inner := func() int {
        outer_var += 99 // attempt to mutate outer_var from outer scope
        return outer_var // =&amp;gt; 101 (but outer_var is a newly redefined
                         //         variable visible only inside inner)
    }
    return inner, outer_var // =&amp;gt; 101, 2 (outer_var is still 2, not mutated by foo!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variadic-functions&#34;&gt;Variadic Functions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	fmt.Println(adder(1, 2, 3)) 	// 6
	fmt.Println(adder(9, 9))	// 18

	nums := []int{10, 20, 30}
	fmt.Println(adder(nums...))	// 60
}

// By using ... before the type name of the last parameter you can indicate that it takes zero or more of those parameters.
// The function is invoked like any other function except we can pass as many arguments as we want.
func adder(args ...int) int {
	total := 0
	for _, v := range args { // Iterates over the arguments whatever the number.
		total += v
	}
	return total
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;built-in-types&#34;&gt;Built-in Types&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32 ~= a character (Unicode code point) - very Viking

float32 float64

complex64 complex128
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-conversions&#34;&gt;Type Conversions&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// alternative syntax
i := 42
f := float64(i)
u := uint(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;packages&#34;&gt;Packages&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Package declaration at top of every source file&lt;/li&gt;
&lt;li&gt;Executables are in package &lt;code&gt;main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Convention: package name == last name of import path (import path &lt;code&gt;math/rand&lt;/code&gt; =&amp;gt; package &lt;code&gt;rand&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Upper case identifier: exported (visible from other packages)&lt;/li&gt;
&lt;li&gt;Lower case identifier: private (not visible from other packages)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;control-structures&#34;&gt;Control structures&lt;/h2&gt;

&lt;h3 id=&#34;if&#34;&gt;If&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	// Basic one
	if x &amp;gt; 0 {
		return x
	} else {
		return -x
	}

	// You can put one statement before the condition
	if a := b + c; a &amp;lt; 42 {
		return a
	} else {
		return a - 42
	}

	// Type assertion inside if
	var val interface{}
	val = &amp;quot;foo&amp;quot;
	if str, ok := val.(string); ok {
		fmt.Println(str)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;Loops&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // There&#39;s only `for`, no `while`, no `until`
    for i := 1; i &amp;lt; 10; i++ {
    }
    for ; i &amp;lt; 10;  { // while - loop
    }
    for i &amp;lt; 10  { // you can omit semicolons if there is only a condition
    }
    for { // you can omit the condition ~ while (true)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;switch&#34;&gt;Switch&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // switch statement
    switch operatingSystem {
    case &amp;quot;darwin&amp;quot;:
        fmt.Println(&amp;quot;Mac OS Hipster&amp;quot;)
        // cases break automatically, no fallthrough by default
    case &amp;quot;linux&amp;quot;:
        fmt.Println(&amp;quot;Linux Geek&amp;quot;)
    default:
        // Windows, BSD, ...
        fmt.Println(&amp;quot;Other&amp;quot;)
    }

    // as with for and if, you can have an assignment statement before the switch value
    switch os := runtime.GOOS; os {
    case &amp;quot;darwin&amp;quot;: ...
    }

    // you can also make comparisons in switch cases
    number := 42
    switch {
        case number &amp;lt; 42:
            fmt.Println(&amp;quot;Smaller&amp;quot;)
        case number == 42:
            fmt.Println(&amp;quot;Equal&amp;quot;)
        case number &amp;gt; 42:
            fmt.Println(&amp;quot;Greater&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arrays-slices-ranges&#34;&gt;Arrays, Slices, Ranges&lt;/h2&gt;

&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a [10]int // declare an int array with length 10. Array length is part of the type!
a[3] = 42     // set elements
i := a[3]     // read elements

// declare and initialize
var a = [2]int{1, 2}
a := [2]int{1, 2} //shorthand
a := [...]int{1, 2} // elipsis -&amp;gt; Compiler figures out array length
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;slices&#34;&gt;Slices&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a []int                              // declare a slice - similar to an array, but length is unspecified
var a = []int {1, 2, 3, 4}               // declare and initialize a slice (backed by the array given implicitly)
a := []int{1, 2, 3, 4}                   // shorthand
chars := []string{0:&amp;quot;a&amp;quot;, 2:&amp;quot;c&amp;quot;, 1: &amp;quot;b&amp;quot;}  // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]

var b = a[lo:hi]	// creates a slice (view of the array) from index lo to hi-1
var b = a[1:4]		// slice from index 1 to 3
var b = a[:3]		// missing low index implies 0
var b = a[3:]		// missing high index implies len(a)
a =  append(a,17,3)	// append items to slice a
c := append(a,b...)	// concatenate slices a and b

// create a slice with make
a = make([]byte, 5, 5)	// first arg length, second capacity
a = make([]byte, 5)	// capacity is optional

// create a slice from an array
x := [3]string{&amp;quot;Лайка&amp;quot;, &amp;quot;Белка&amp;quot;, &amp;quot;Стрелка&amp;quot;}
s := x[:] // a slice referencing the storage of x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;operations-on-arrays-and-slices&#34;&gt;Operations on Arrays and Slices&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;len(a)&lt;/code&gt; gives you the length of an array/a slice. It&amp;rsquo;s a built-in function, not a attribute/method on the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// loop over an array/a slice
for i, e := range a {
    // i is the index, e the element
}

// if you only need e:
for _, e := range a {
    // e is the element
}

// ...and if you only need the index
for i := range a {
}

// In Go pre-1.4, you&#39;ll get a compiler error if you&#39;re not using i and e.
// Go 1.4 introduced a variable-free form, so that you can do this
for range time.Tick(time.Second) {
    // do it once a sec
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maps&#34;&gt;Maps&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
m = make(map[string]int)
m[&amp;quot;key&amp;quot;] = 42
fmt.Println(m[&amp;quot;key&amp;quot;])

delete(m, &amp;quot;key&amp;quot;)

elem, ok := m[&amp;quot;key&amp;quot;] // test if key &amp;quot;key&amp;quot; is present and retrieve it, if so

// map literal
var m = map[string]Vertex{
    &amp;quot;Bell Labs&amp;quot;: {40.68433, -74.39967},
    &amp;quot;Google&amp;quot;:    {37.42202, -122.08408},
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;structs&#34;&gt;Structs&lt;/h2&gt;

&lt;p&gt;There are no classes, only structs. Structs can have methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A struct is a type. It&#39;s also a collection of fields

// Declaration
type Vertex struct {
    X, Y int
}

// Creating
var v = Vertex{1, 2}
var v = Vertex{X: 1, Y: 2} // Creates a struct by defining values with keys
var v = []Vertex{{1,2},{5,2},{5,5}} // Initialize a slice of structs

// Accessing members
v.X = 4

// You can declare methods on structs. The struct you want to declare the
// method on (the receiving type) comes between the the func keyword and
// the method name. The struct is copied on each method call(!)
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// Call method
v.Abs()

// For mutating methods, you need to use a pointer (see below) to the Struct
// as the type. With this, the struct value is not copied for the method call.
func (v *Vertex) add(n float64) {
    v.X += n
    v.Y += n
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Anonymous structs:&lt;/strong&gt;
Cheaper and safer than using &lt;code&gt;map[string]interface{}&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;point := struct {
	X, Y int
}{1, 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pointers&#34;&gt;Pointers&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Vertex{1, 2}  // p is a Vertex
q := &amp;amp;p            // q is a pointer to a Vertex
r := &amp;amp;Vertex{1, 2} // r is also a pointer to a Vertex

// The type of a pointer to a Vertex is *Vertex

var s *Vertex = new(Vertex) // new creates a pointer to a new struct instance
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// interface declaration
type Awesomizer interface {
    Awesomize() string
}

// types do *not* declare to implement interfaces
type Foo struct {}

// instead, types implicitly satisfy an interface if they implement all required methods
func (foo Foo) Awesomize() string {
    return &amp;quot;Awesome!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;embedding&#34;&gt;Embedding&lt;/h2&gt;

&lt;p&gt;There is no subclassing in Go. Instead, there is interface and struct embedding.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ReadWriter implementations must satisfy both Reader and Writer
type ReadWriter interface {
    Reader
    Writer
}

// Server exposes all the methods that Logger has
type Server struct {
    Host string
    Port int
    *log.Logger
}

// initialize the embedded type the usual way
server := &amp;amp;Server{&amp;quot;localhost&amp;quot;, 80, log.New(...)}

// methods implemented on the embedded struct are passed through
server.Log(...) // calls server.Logger.Log(...)

// the field name of the embedded type is its type name (in this case Logger)
var logger *log.Logger = server.Logger
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;errors&#34;&gt;Errors&lt;/h2&gt;

&lt;p&gt;There is no exception handling. Functions that might produce an error just declare an additional return value of type &lt;code&gt;Error&lt;/code&gt;. This is the &lt;code&gt;Error&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function that might return an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func doStuff() (int, error) {
}

func main() {
    result, error := doStuff()
    if (error != nil) {
        // handle error
    } else {
        // all is good, use result
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;h2 id=&#34;goroutines&#34;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;Goroutines are lightweight threads (managed by Go, not OS threads). &lt;code&gt;go f(a, b)&lt;/code&gt; starts a new goroutine which runs &lt;code&gt;f&lt;/code&gt; (given &lt;code&gt;f&lt;/code&gt; is a function).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// just a function (which can be later started as a goroutine)
func doStuff(s string) {
}

func main() {
    // using a named function in a goroutine
    go doStuff(&amp;quot;foobar&amp;quot;)

    // using an anonymous inner function in a goroutine
    go func (x int) {
        // function body goes here
    }(42)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;channels&#34;&gt;Channels&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := make(chan int) // create a channel of type int
ch &amp;lt;- 42             // Send a value to the channel ch.
v := &amp;lt;-ch            // Receive a value from ch

// Non-buffered channels block. Read blocks when no value is available, write blocks if a value already has been written but not read.

// Create a buffered channel. Writing to a buffered channels does not block if less than &amp;lt;buffer size&amp;gt; unread values have been written.
ch := make(chan int, 100)

close(ch) // closes the channel (only sender should close)

// read from channel and test if it has been closed
v, ok := &amp;lt;-ch

// if ok is false, channel has been closed

// Read from channel until it is closed
for i := range ch {
    fmt.Println(i)
}

// select blocks on multiple channel operations, if one unblocks, the corresponding case is executed
func doStuff(channelOut, channelIn chan int) {
    select {
    case channelOut &amp;lt;- 42:
        fmt.Println(&amp;quot;We could write to channelOut!&amp;quot;)
    case x := &amp;lt;- channelIn:
        fmt.Println(&amp;quot;We could read from channelIn&amp;quot;)
    case &amp;lt;-time.After(time.Second * 1):
        fmt.Println(&amp;quot;timeout&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;channel-axioms&#34;&gt;Channel Axioms&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A send to a nil channel blocks forever&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var c chan string
  c &amp;lt;- &amp;quot;Hello, World!&amp;quot;
  // fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A receive from a nil channel blocks forever&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var c chan string
  fmt.Println(&amp;lt;-c)
  // fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A send to a closed channel panics&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var c = make(chan string, 1)
  c &amp;lt;- &amp;quot;Hello, World!&amp;quot;
  close(c)
  c &amp;lt;- &amp;quot;Hello, Panic!&amp;quot;
  // panic: send on closed channel
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A receive from a closed channel returns the zero value immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var c = make(chan int, 2)
  c &amp;lt;- 1
  c &amp;lt;- 2
  close(c)
  for i := 0; i &amp;lt; 3; i++ {
      fmt.Printf(&amp;quot;%d &amp;quot;, &amp;lt;-c)
  }
  // 1 2 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;printing&#34;&gt;Printing&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(&amp;quot;Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ&amp;quot;) // basic print, plus newline
p := struct { X, Y int }{ 17, 2 }
fmt.Println( &amp;quot;My point:&amp;quot;, p, &amp;quot;x coord=&amp;quot;, p.X ) // print structs, ints, etc
s := fmt.Sprintln( &amp;quot;My point:&amp;quot;, p, &amp;quot;x coord=&amp;quot;, p.X ) // print to string variable

fmt.Printf(&amp;quot;%d hex:%x bin:%b fp:%f sci:%e&amp;quot;,17,17,17,17.0,17.0) // c-ish format
s2 := fmt.Sprintf( &amp;quot;%d %f&amp;quot;, 17, 17.0 ) // formatted print to string variable

hellomsg := `
 &amp;quot;Hello&amp;quot; in Chinese is 你好 (&#39;Ni Hao&#39;)
 &amp;quot;Hello&amp;quot; in Hindi is नमस्ते (&#39;Namaste&#39;)
` // multi-line string literal, using back-tick at beginning and end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;snippets&#34;&gt;Snippets&lt;/h1&gt;

&lt;h2 id=&#34;http-server&#34;&gt;HTTP Server&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
)

// define a type for the response
type Hello struct{}

// let that type implement the ServeHTTP method (defined in interface http.Handler)
func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, &amp;quot;Hello!&amp;quot;)
}

func main() {
    var h Hello
    http.ListenAndServe(&amp;quot;localhost:4000&amp;quot;, h)
}

// Here&#39;s the method signature of http.ServeHTTP:
// type Handler interface {
//     ServeHTTP(w http.ResponseWriter, r *http.Request)
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/a8m/go-lang-cheat-sheet&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;原文出处&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://vxgo.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://vxgo.github.io/about/</guid>
      <description>

&lt;blockquote class=&#39;blockquote-center&#39;&gt;如果在乎的没有那么多，想要的没有那么，生活便会简单得很多
简单 == 幸福
&lt;/blockquote&gt;

&lt;h1 id=&#34;about-me-2&#34;&gt;&lt;a href=&#34;https://about.me/ehlxr&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;About Me&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;我就是我，是写程序的我，哈哈&amp;hellip;&lt;/p&gt;

&lt;p&gt;混迹 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 世界的老菜鸟程序猿一枚，&lt;code&gt;Java&lt;/code&gt; 懂点，&lt;code&gt;Linux&lt;/code&gt; 会点，&lt;code&gt;Golang&lt;/code&gt; 了解点，&lt;code&gt;前端&lt;/code&gt; 知道点，&lt;code&gt;Python&lt;/code&gt; 看了一点，&lt;code&gt;Android&lt;/code&gt; 忘得差不多了，&lt;code&gt;C&lt;/code&gt; 语言忘光了；爱折腾，但是很懒，能动手就不说话，但不闷骚哦！（嗯，不错，很程序猿）&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;about-blog&#34;&gt;About Blog&lt;/h1&gt;

&lt;p&gt;作为一个程序猿，而且是一个喜欢 “装逼” 的程序猿，没有一个自己的 &lt;code&gt;blog&lt;/code&gt; 是不是不够拉轰啊，哈哈！&lt;/p&gt;

&lt;p&gt;本站是使用 &lt;a href=&#34;https://gohugo.io/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Hugo&lt;/code&gt;&lt;/a&gt; 博客框架搭建，镜像托管在 &lt;a href=&#34;https://pages.github.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Github Pages&lt;/code&gt;&lt;/a&gt; 之上，博客主题基于非常漂亮、简洁的 &lt;a href=&#34;https://github.com/olOwOlo/hugo-theme-even/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Even&lt;/code&gt;&lt;/a&gt; 主题修改而来。&lt;/p&gt;

&lt;p&gt;在此感谢这些技术的提供者们，是你们的无私的奉献，才成就了千千万万像我这样的非专业选手能够搭建这么漂亮的个人博客，让我们能够有这么一个小天地和大家分享技术、分享生活。。。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;copyright&#34;&gt;Copyright&lt;/h1&gt;

&lt;p&gt;&lt;font color=&#39;#DC143C&#39;&gt;本站是为了个人交流学习而搭建，本站内容若非注明【转】均来自本人原创，转载必会注明原文引用地址，若您认为侵犯你的个人知识产权，请联系 &lt;a href=&#34;mailto:ehlxr.me@gmail.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;我邮箱&lt;/a&gt;，我会第一时间和您进行沟通处理。若你喜欢本站内容，欢迎转载，但请注明出处，且勿用于商业用途，谢谢！！！&lt;/font&gt;
&lt;br&gt;
&lt;!-- &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/4.0/&#34;&gt;&lt;img alt=&#34;知识共享许可协议&#34; style=&#34;border-width:0&#34; src=&#34;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&#34; /&gt;&lt;/a&gt;&lt;br /&gt;本站采用&lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/4.0/&#34;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。 --&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;!-- &lt;script type=&#34;text/javascript&#34; src=&#34;http://static.zgboke.com/hutui.js&#34;&gt;&lt;/script&gt; --&gt;

&lt;!-- &lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=110 src=&#34;//music.163.com/outchain/player?type=0&amp;id=448161195&amp;auto=1&amp;height=90&#34;&gt;&lt;/iframe&gt; --&gt;

&lt;!-- &lt;audio autoplay=&#34;autoplay&#34; loop=&#34;loop&#34;&gt;
    &lt;source src=&#34;http://oapjp6spr.bkt.clouddn.com/%E5%AE%97%E6%AC%A1%E9%83%8E%20-%20%E3%81%84%E3%81%A4%E3%82%82%E4%BD%95%E5%BA%A6%E3%81%A7%E3%82%82.mp3&#34; /&gt;
    Your browser does not support the audio element.
&lt;/audio&gt; --&gt;

&lt;!-- &lt;iframe src=&#34;https://music.daoapp.io/iframe?song=480353&amp;qssl=1&amp;qnarrow=0&amp;max_width=100%&amp;autoplay=1&#34; height= &#34;90%&#34; width=&#34;100%&#34; frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; allowtransparency=&#34;yes&#34;&gt;&lt;/iframe&gt; --&gt;

&lt;!-- &lt;div class=&#34;ds-recent-visitors&#34; data-num-items=&#34;28&#34; data-avatar-size=&#34;42&#34; id=&#34;ds-recent-visitors&#34;/&gt; --&gt;
</description>
    </item>
    
    <item>
      <title>Link</title>
      <link>https://vxgo.github.io/link/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://vxgo.github.io/link/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;欢迎添加友链！！！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;我的信息&#34;&gt;我的信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;名称：ehlxr&lt;/li&gt;
&lt;li&gt;简介（如果需要）：胡编一通，乱写一气&amp;hellip;&lt;/li&gt;
&lt;li&gt;图标（如果需要）：&lt;a href=&#34;https://wx2.sinaimg.cn/large/687148dbly1fnzyvs4thqj20xc0xc0zy.jpg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;原始尺寸&lt;/a&gt;，更多尺寸 &lt;a href=&#34;https://wx4.sinaimg.cn/large/687148dbly1fnzzfuvrnij20dc0dcdg7.jpg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;480*480&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;申请友链须知&#34;&gt;申请友链须知&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;优先于技术、生活分享类博客站点友链，坚决不和论坛、导航、含有暴力等不健康信息内容站点做任何交换。&lt;/li&gt;
&lt;li&gt;申请链接前请先添加本博链接。&lt;/li&gt;
&lt;li&gt;申请请提供：站点名称、站点链接、站点描述和头像链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;style&gt;
    table  {
        width: 100%;
    }
    table th:first-of-type {
        width: 35%;
    }
    table th:nth-of-type(2) {
        width: 65%;
    }
&lt;/style&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;站点&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/687148dbly1fnzyvs4thqj20xc0xc0zy.jpg&#34; width=&#34;48&#34; height=&#34;48&#34; align=center /&gt; &lt;a href=&#34;https://ehlxr.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Ehlxr&amp;rsquo;s Blog&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;「闲言碎语」&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/687148dbly1fnzyvs4thqj20xc0xc0zy.jpg&#34; width=&#34;48&#34; height=&#34;48&#34; align=center /&gt;&lt;a href=&#34;https://ehlxr.top&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;匆匆那年&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;胡编一通，乱写一气&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>